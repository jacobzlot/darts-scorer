<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Dart Practice - Live Match</title>
<link rel="stylesheet" href="style.css">
</head>

<body>

<!-- Header -->
<header class="site-header">
  <div class="header-content">
    <div class="logo-section">
      <img src="dartpractice-logo.png" alt="Dart Practice" class="site-logo" onerror="this.style.display='none'">
      <div class="site-name">
        <span class="site-title">DartPractice</span>
        <span class="site-domain">.com</span>
      </div>
    </div>
    <nav class="header-nav">
      <a href="gamesetup.html" class="nav-link">New Match</a>
      <a href="#" class="nav-link">Stats</a>
      <a href="#" class="nav-link">About</a>
      <button class="theme-toggle" id="themeToggle" onclick="toggleTheme()" title="Toggle dark mode">
        <span id="themeIcon">ðŸŒ™</span>
      </button>
    </nav>
  </div>
</header>

<div class="scoreboard">

  <div id="matchInfo" class="match-info"></div>

  <div class="score-row">
    <div class="score-col">
      <div id="p1Score" class="big-score">501</div>
      <div id="p1Name" class="player-name"></div>
    </div>

    <div class="legs-display">
      <div class="legs-grid">
        <div class="leg-item">LEGS<span id="p1Legs">0</span></div>
        <div class="leg-item">LEGS<span id="p2Legs">0</span></div>
      </div>
      <div class="sets-grid" id="setsGrid">
        <div class="leg-item">SETS<span id="p1Sets">0</span></div>
        <div class="leg-item">SETS<span id="p2Sets">0</span></div>
      </div>
    </div>

    <div class="score-col">
      <div id="p2Score" class="big-score">501</div>
      <div id="p2Name" class="player-name-right"></div>
    </div>
  </div>

  <div class="dotted-line"></div>

  <div class="input-section">
    <input id="throwInput" class="throw-input" type="number" min="0" max="180" placeholder="Enter score">
  </div>

  <div class="dotted-line"></div>

  <div class="bottom-row">
    <div class="side-stats">
      <h3>GAME AVERAGES</h3>
      <table>
        <tr><td>3 DART</td><td id="p1Avg3">â€”</td></tr>
        <tr><td>1 DART</td><td id="p1Avg1">â€”</td></tr>
      </table>
      <h3>AMOUNT</h3>
      <table>
        <tr><td>180'S</td><td id="p1_180s">0</td></tr>
        <tr><td>160 - 179</td><td id="p1_160">0</td></tr>
        <tr><td>140 - 159</td><td id="p1_140">0</td></tr>
        <tr><td>120 - 139</td><td id="p1_120">0</td></tr>
        <tr><td>100 - 119</td><td id="p1_100">0</td></tr>
        <tr><td>80 - 99</td><td id="p1_80">0</td></tr>
        <tr><td>60 - 79</td><td id="p1_60">0</td></tr>
        <tr><td>0 - 59</td><td id="p1_0">0</td></tr>
      </table>
    </div>

    <div class="center-history">
      <div class="history-cols">
        <ul id="p1History" class="history-list"></ul>
        <ul id="p2History" class="history-list"></ul>
      </div>
    </div>

    <div class="side-stats">
      <h3>GAME AVERAGES</h3>
      <table>
        <tr><td>3 DART</td><td id="p2Avg3">â€”</td></tr>
        <tr><td>1 DART</td><td id="p2Avg1">â€”</td></tr>
      </table>
      <h3>AMOUNT</h3>
      <table>
        <tr><td>180'S</td><td id="p2_180s">0</td></tr>
        <tr><td>160 - 179</td><td id="p2_160">0</td></tr>
        <tr><td>140 - 159</td><td id="p2_140">0</td></tr>
        <tr><td>120 - 139</td><td id="p2_120">0</td></tr>
        <tr><td>100 - 119</td><td id="p2_100">0</td></tr>
        <tr><td>80 - 99</td><td id="p2_80">0</td></tr>
        <tr><td>60 - 79</td><td id="p2_60">0</td></tr>
        <tr><td>0 - 59</td><td id="p2_0">0</td></tr>
      </table>
    </div>
  </div>

  <div class="hidden-controls">
    <button class="action" onclick="undo()">âŸ²</button>
    <button class="action" onclick="submitThrow()">âž¤</button>
  </div>

</div>

<script>
// Theme Toggle
function toggleTheme() {
  const body = document.body;
  const themeIcon = document.getElementById('themeIcon');
  
  body.classList.toggle('dark-mode');
  
  if (body.classList.contains('dark-mode')) {
    themeIcon.textContent = 'â˜€ï¸';
    localStorage.setItem('theme', 'dark');
  } else {
    themeIcon.textContent = 'ðŸŒ™';
    localStorage.setItem('theme', 'light');
  }
}

// Load saved theme on page load
(function() {
  const savedTheme = localStorage.getItem('theme');
  const body = document.body;
  const themeIcon = document.getElementById('themeIcon');
  
  if (savedTheme === 'dark') {
    body.classList.add('dark-mode');
    if(themeIcon) themeIcon.textContent = 'â˜€ï¸';
  }
})();

let START = 501;
const $ = id => document.getElementById(id);

const Engine = {
  cfg:{},
  state:{
    p1Score:START,p2Score:START,
    p1Legs:0,p2Legs:0,
    p1Sets:0,p2Sets:0,
    turn:0,
    p1Hist:[],p2Hist:[],
    p1Pts:0,p2Pts:0,
    p1Turns:0,p2Turns:0,
    undo:[],
    // Match-level cumulative stats
    matchP1Pts:0,matchP2Pts:0,
    matchP1Turns:0,matchP2Turns:0,
    currentSetStarter:0, // Who started current set
    matchOver:false
  },

  snapshot(){ return JSON.parse(JSON.stringify(this.state)); },
  restore(s){ this.state=s; },

  resetLeg(next){
    const s=this.state;
    s.p1Score=s.p2Score=START;
    s.turn=next;
    // Clear history for new leg - start fresh
    s.p1Hist = [{type:"start",score:START}];
    s.p2Hist = [{type:"start",score:START}];
    // Clear leg-level stats (match stats persist)
    s.p1Pts=s.p2Pts=0;
    s.p1Turns=s.p2Turns=0;
  },

  apply(score){
    const s=this.state;
    
    // Limit undo stack to last 10 moves for performance
    s.undo.push(this.snapshot());
    if(s.undo.length > 10){
      s.undo.shift(); // Remove oldest
    }

    const isP1=s.turn===0;
    const cur=isP1?s.p1Score:s.p2Score;
    const hist=isP1?s.p1Hist:s.p2Hist;

    if(isP1){
      s.p1Turns++;
      s.matchP1Turns++; // Track cumulative
    } else {
      s.p2Turns++;
      s.matchP2Turns++; // Track cumulative
    }

    const after=cur-score;
    if(after<0||after===1){
      hist.push({type:"bust"});
      
      // Cap history array at 25 items for performance
      if(hist.length > 25) hist.shift();
      
      s.turn^=1;
      return;
    }

    hist.push({type:"turn",scored:score,to:after});
    
    // Cap history array at 25 items for performance
    if(hist.length > 25) hist.shift();
    
    if(isP1){
      s.p1Score=after;
      s.p1Pts+=score;
      s.matchP1Pts+=score; // Track cumulative
    }
    else{
      s.p2Score=after;
      s.p2Pts+=score;
      s.matchP2Pts+=score; // Track cumulative
    }

    if(after===0){
      hist.push({type:"finish"});
      
      // Cap history array at 25 items for performance
      if(hist.length > 25) hist.shift();
      
      this.winLeg(isP1?0:1);
      return;
    }
    s.turn^=1;
  },

  winLeg(w){
    const s=this.state;
    if(w===0)s.p1Legs++; else s.p2Legs++;

    // Check if set is won
    if(s.p1Legs===this.cfg.legs||s.p2Legs===this.cfg.legs){
      if(s.p1Legs===this.cfg.legs)s.p1Sets++;
      else s.p2Sets++;
      
      // Check if match is won
      if(s.p1Sets===this.cfg.sets || s.p2Sets===this.cfg.sets){
        s.matchOver = true;
        showGameOver(s.p1Sets === this.cfg.sets ? 0 : 1);
        return; // Don't reset leg - match is over
      }
      
      // Set won but match continues - alternate throw for next set
      s.currentSetStarter = s.currentSetStarter ^ 1;
      s.p1Legs=s.p2Legs=0;
      this.resetLeg(s.currentSetStarter);
    } else {
      // Leg won but set continues - normal throw alternation
      this.resetLeg(w^1);
    }
  }
};

// ========== EFFICIENT RENDER SYSTEM ==========
// Track what was last rendered to avoid unnecessary DOM updates
let lastRendered = {
  p1Score: null,
  p2Score: null,
  p1Legs: null,
  p2Legs: null,
  p1Sets: null,
  p2Sets: null,
  p1HistLen: 0,
  p2HistLen: 0
};

function renderHist(id, h){
  // This function is now only called when history actually changed
  const ul = $(id);
  const isP1 = id === "p1History";
  const lastLen = isP1 ? lastRendered.p1HistLen : lastRendered.p2HistLen;
  
  // If history was reset (new leg) OR capped (shifted items), rebuild
  if(h.length <= lastLen){
    ul.innerHTML = "";
    
    // Rebuild from scratch
    const frag = document.createDocumentFragment();
    h.forEach(e => {
      const li = document.createElement('li');
      if(e.type === "start"){
        li.className = 'hist-item start';
        li.textContent = e.score;
      } else if(e.type === "turn"){
        li.className = 'hist-item';
        li.innerHTML = `<span class="scored">${e.scored}</span><span class="remain">${e.to}</span>`;
      } else if(e.type === "bust"){
        li.className = 'hist-item bust';
        li.textContent = 'BUST';
      } else if(e.type === "finish"){
        li.className = 'hist-item finish';
        li.textContent = 'FINISH';
      }
      frag.appendChild(li);
    });
    ul.appendChild(frag);
    
    // Update tracking
    if(isP1) lastRendered.p1HistLen = h.length;
    else lastRendered.p2HistLen = h.length;
    
    // Auto-scroll
    ul.scrollTop = ul.scrollHeight;
    return;
  }
  
  // Only process new items (append only)
  const newItems = h.slice(lastLen);
  if(newItems.length === 0) return;
  
  // Use document fragment for efficient batch DOM insertion
  const frag = document.createDocumentFragment();
  
  newItems.forEach(e => {
    const li = document.createElement('li');
    if(e.type === "start"){
      li.className = 'hist-item start';
      li.textContent = e.score;
    } else if(e.type === "turn"){
      li.className = 'hist-item';
      li.innerHTML = `<span class="scored">${e.scored}</span><span class="remain">${e.to}</span>`;
    } else if(e.type === "bust"){
      li.className = 'hist-item bust';
      li.textContent = 'BUST';
    } else if(e.type === "finish"){
      li.className = 'hist-item finish';
      li.textContent = 'FINISH';
    }
    frag.appendChild(li);
  });
  
  ul.appendChild(frag);
  
  // Update tracking
  if(isP1) lastRendered.p1HistLen = h.length;
  else lastRendered.p2HistLen = h.length;
  
  // Auto-scroll
  ul.scrollTop = ul.scrollHeight;
}

function render(){
  const s = Engine.state;
  
  // Only update if changed
  if(s.p1Score !== lastRendered.p1Score){
    $("p1Score").textContent = s.p1Score;
    lastRendered.p1Score = s.p1Score;
  }
  
  if(s.p2Score !== lastRendered.p2Score){
    $("p2Score").textContent = s.p2Score;
    lastRendered.p2Score = s.p2Score;
  }
  
  if(s.p1Legs !== lastRendered.p1Legs){
    $("p1Legs").textContent = s.p1Legs;
    lastRendered.p1Legs = s.p1Legs;
  }
  
  if(s.p2Legs !== lastRendered.p2Legs){
    $("p2Legs").textContent = s.p2Legs;
    lastRendered.p2Legs = s.p2Legs;
  }
  
  if(s.p1Sets !== lastRendered.p1Sets){
    $("p1Sets").textContent = s.p1Sets;
    lastRendered.p1Sets = s.p1Sets;
  }
  
  if(s.p2Sets !== lastRendered.p2Sets){
    $("p2Sets").textContent = s.p2Sets;
    lastRendered.p2Sets = s.p2Sets;
  }
  
  // Only render history if it changed
  if(s.p1Hist.length !== lastRendered.p1HistLen){
    renderHist("p1History", s.p1Hist);
  }
  
  if(s.p2Hist.length !== lastRendered.p2HistLen){
    renderHist("p2History", s.p2Hist);
  }
  
  // Update averages (always update these as they change frequently)
  $("p1Avg3").textContent = s.matchP1Turns ? (s.matchP1Pts/s.matchP1Turns).toFixed(2) : "â€”";
  $("p2Avg3").textContent = s.matchP2Turns ? (s.matchP2Pts/s.matchP2Turns).toFixed(2) : "â€”";
  $("p1Avg1").textContent = s.matchP1Turns ? (s.matchP1Pts/s.matchP1Turns/3).toFixed(2) : "â€”";
  $("p2Avg1").textContent = s.matchP2Turns ? (s.matchP2Pts/s.matchP2Turns/3).toFixed(2) : "â€”";
}

function initMatch(){
  // Load config from localStorage
  const configStr = localStorage.getItem("dartsConfig");
  if(!configStr){
    alert("No match configuration found. Redirecting to setup...");
    window.location.href = "gamesetup.html";
    return;
  }
  
  Engine.cfg = JSON.parse(configStr);
  
  // Set the starting score based on game type
  START = Engine.cfg.gameType || 501;
  
  // Initialize match state
  Engine.state.currentSetStarter = 0; // Player 1 starts first set
  Engine.state.matchP1Pts = 0;
  Engine.state.matchP2Pts = 0;
  Engine.state.matchP1Turns = 0;
  Engine.state.matchP2Turns = 0;
  Engine.state.matchOver = false;
  
  Engine.resetLeg(0);
  
  $("p1Name").textContent=Engine.cfg.p1;
  $("p2Name").textContent=Engine.cfg.p2;
  
  // Update match info text
  let matchText = `${START} GAME â€” FIRST TO ${Engine.cfg.legs} LEGS`;
  if(Engine.cfg.sets > 1){
    matchText = `${START} GAME â€” BEST OF ${Engine.cfg.sets} SETS`;
  }
  
  $("matchInfo").textContent = matchText;
  
  // Hide SETS display if only 1 set
  if(Engine.cfg.sets === 1){
    const setsGrid = document.getElementById('setsGrid');
    if(setsGrid){
      setsGrid.style.display = 'none';
    }
  }
  
  render();
  $("throwInput").focus();
  
  // If AI starts, play their turn
  if(Engine.cfg.isAI && Engine.state.turn === 1){
    $("throwInput").disabled = true;
    requestAnimationFrame(() => {
      setTimeout(() => {
        playAITurn();
        $("throwInput").disabled = false;
        $("throwInput").focus();
      }, 800);
    });
  }
}

function showGameOver(winner){
  const s = Engine.state;
  const winnerName = winner === 0 ? Engine.cfg.p1 : Engine.cfg.p2;
  const winnerSets = winner === 0 ? s.p1Sets : s.p2Sets;
  const loserSets = winner === 0 ? s.p2Sets : s.p1Sets;
  const winnerAvg = winner === 0 ? 
    (s.matchP1Turns ? (s.matchP1Pts/s.matchP1Turns).toFixed(2) : "0.00") :
    (s.matchP2Turns ? (s.matchP2Pts/s.matchP2Turns).toFixed(2) : "0.00");
  
  // Create game over modal
  const modal = document.createElement('div');
  modal.id = 'gameOverModal';
  modal.className = 'game-over-modal';
  modal.innerHTML = `
    <div class="game-over-content">
      <h1 class="game-over-title">GAME OVER</h1>
      <div class="winner-banner">
        <div class="winner-name">${winnerName}</div>
        <div class="winner-subtitle">WINS THE MATCH!</div>
      </div>
      <div class="match-result">
        <div class="result-sets">${winnerSets} - ${loserSets}</div>
        <div class="result-label">SETS</div>
      </div>
      <div class="match-stats">
        <div class="stat-item">
          <div class="stat-label">Match Average</div>
          <div class="stat-value">${winnerAvg}</div>
        </div>
      </div>
      <div class="game-over-buttons">
        <button onclick="location.href='gamesetup.html'" class="btn-new-match">NEW MATCH</button>
        <button onclick="closeGameOver()" class="btn-review">REVIEW SCORES</button>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // Disable input
  $("throwInput").disabled = true;
  
  // Focus on new match button
  setTimeout(() => {
    const newMatchBtn = modal.querySelector('.btn-new-match');
    if(newMatchBtn) newMatchBtn.focus();
  }, 100);
}

function closeGameOver(){
  const modal = document.getElementById('gameOverModal');
  if(modal) modal.remove();
}

function submitThrow(){
  // Don't allow input if match is over
  if(Engine.state.matchOver) return;
  
  const v=+$("throwInput").value;
  $("throwInput").value="";
  if(v<0||v>180)return;
  Engine.apply(v);
  render();
  
  // Check if match ended
  if(Engine.state.matchOver) return;
  
  // Check if it's AI's turn and game is still active
  if(Engine.cfg.isAI && Engine.state.turn === 1 && Engine.state.p2Score > 0){
    // Disable input during AI turn
    $("throwInput").disabled = true;
    
    // Use requestAnimationFrame for smoother performance
    requestAnimationFrame(() => {
      setTimeout(() => {
        playAITurn();
        $("throwInput").disabled = false;
        $("throwInput").focus();
      }, 600); // Reduced from 800ms for faster play
    });
  }
}

// Debounce AI turns
let aiTurnPending = false;

function playAITurn(){
  if(aiTurnPending) return; // Prevent rapid-fire AI turns
  aiTurnPending = true;
  
  const avg = Engine.cfg.aiAverage;
  const checkoutPct = Engine.cfg.aiCheckout / 100;
  const remaining = Engine.state.p2Score;
  
  let score;
  
  // Determine if AI is on a finish
  if(remaining <= 170 && remaining !== 169 && remaining !== 168 && remaining !== 166 && 
     remaining !== 165 && remaining !== 163 && remaining !== 162 && remaining !== 159){
    
    // Checkout difficulty modifier
    let checkoutDifficulty = 1.0;
    if(remaining <= 40) checkoutDifficulty = 1.5;
    else if(remaining <= 100) checkoutDifficulty = 1.2;
    else checkoutDifficulty = 0.7;
    
    const adjustedCheckoutChance = checkoutPct * checkoutDifficulty;
    
    if(Math.random() < adjustedCheckoutChance){
      score = remaining; // Successfully finish
    } else {
      // Miss the checkout - use OVERALL average (not inflated)
      score = simulateCheckoutAttempt(avg, remaining);
    }
  } else {
    // Not on a finish - use OVERALL average directly
    // The average already accounts for everything including poor checkouts
    score = simulateThreeDarts(avg, remaining, false);
  }
  
  Engine.apply(score);
  
  // Use requestAnimationFrame for smoother rendering
  requestAnimationFrame(() => {
    render();
    setTimeout(() => {
      aiTurnPending = false; // Reset after delay
    }, 100);
  });
}

// Calculate actual SCORING average from overall leg average and checkout %
// Simulate a checkout attempt that misses
function simulateCheckoutAttempt(average, remaining){
  // SIMPLIFIED VERSION - prevent crashes and infinite loops
  // Just throw 3 darts normally, being careful not to bust
  
  let score = 0;
  
  // Throw up to 3 darts
  for(let i = 0; i < 3; i++){
    const dart = throwSingleDart(average);
    
    // Check if adding this dart would bust or leave 1
    if(score + dart >= remaining){
      // Stop here, leave it for next turn
      break;
    }
    
    score += dart;
    
    // If we've left a good finish (<=170), stop
    if(remaining - score <= 170 && remaining - score > 1){
      break;
    }
  }
  
  // Safety checks
  if(score >= remaining) score = Math.max(0, remaining - 10);
  if(remaining - score === 1) score = Math.max(0, score - 1);
  
  return Math.max(0, Math.min(score, remaining - 2));
}

function getTrebleRate(average){
  if(average >= 105) return 0.46;
  else if(average >= 100) return 0.43;
  else if(average >= 95) return 0.40;
  else if(average >= 85) return 0.36;
  else if(average >= 75) return 0.30;
  else if(average >= 60) return 0.22;
  else if(average >= 45) return 0.14;
  else return 0.07;
}

// Simulate throwing 3 darts based on skill level
function simulateThreeDarts(average, remaining, isCheckoutAttempt){
  let totalScore = 0;
  
  // Throw 3 darts with realistic scoring distribution
  for(let i = 0; i < 3; i++){
    totalScore += throwSingleDart(average);
  }
  
  return totalScore;
}

// Simulate a single dart throw based on average
function throwSingleDart(average){
  // Use average to determine scoring distribution
  // Lower average = more misses and low scores
  
  if(average >= 100){
    // Elite players: frequent trebles, rare misses
    const rand = Math.random();
    if(rand < 0.43) return 60; // T20
    if(rand < 0.50) return [57, 54, 51][Math.floor(Math.random() * 3)]; // Other trebles
    if(rand < 0.85) return [20, 19, 18][Math.floor(Math.random() * 3)]; // High singles
    if(rand < 0.95) return [15, 16, 17][Math.floor(Math.random() * 3)]; // Mid singles
    return [5, 1, 12, 9][Math.floor(Math.random() * 4)]; // Misses
  }
  
  if(average >= 85){
    // Professional: good trebles, occasional misses
    const rand = Math.random();
    if(rand < 0.36) return 60; // T20
    if(rand < 0.42) return [57, 54, 51][Math.floor(Math.random() * 3)]; // Other trebles
    if(rand < 0.70) return [20, 19, 18][Math.floor(Math.random() * 3)]; // High singles
    if(rand < 0.88) return [15, 16, 17, 12, 13, 14][Math.floor(Math.random() * 6)]; // Mid singles
    return [5, 1, 9, 11, 7, 3][Math.floor(Math.random() * 6)]; // Misses
  }
  
  if(average >= 70){
    // Solid player: some trebles, regular misses
    const rand = Math.random();
    if(rand < 0.30) return 60; // T20
    if(rand < 0.35) return [57, 54, 51][Math.floor(Math.random() * 3)]; // Other trebles
    if(rand < 0.60) return [20, 19, 18][Math.floor(Math.random() * 3)]; // High singles
    if(rand < 0.80) return [15, 16, 17, 12, 13, 14][Math.floor(Math.random() * 6)]; // Mid singles
    return [5, 1, 9, 11, 7, 3, 8, 10, 6][Math.floor(Math.random() * 9)]; // Misses
  }
  
  if(average >= 55){
    // Intermediate: occasional trebles, many misses
    const rand = Math.random();
    if(rand < 0.20) return 60; // T20 - reduced
    if(rand < 0.24) return [57, 54][Math.floor(Math.random() * 2)]; // Other trebles - rare
    if(rand < 0.44) return [20, 19, 18, 17][Math.floor(Math.random() * 4)]; // High singles
    if(rand < 0.68) return [15, 16, 13, 14, 12, 11][Math.floor(Math.random() * 6)]; // Mid singles
    return [5, 1, 9, 7, 3, 8, 10, 6, 4, 2][Math.floor(Math.random() * 10)]; // Misses
  }
  
  if(average >= 40){
    // Beginner: rare trebles, lots of low scores
    const rand = Math.random();
    if(rand < 0.10) return 60; // T20 - very rare
    if(rand < 0.12) return [57, 54][Math.floor(Math.random() * 2)]; // Other trebles - extremely rare
    if(rand < 0.26) return [20, 19, 18][Math.floor(Math.random() * 3)]; // High singles
    if(rand < 0.50) return [15, 16, 13, 14, 12, 11, 10, 9][Math.floor(Math.random() * 8)]; // Mid singles
    return [5, 1, 7, 3, 8, 6, 4, 2, 17, 11, 9, 12, 10][Math.floor(Math.random() * 13)]; // Low scores
  }
  
  // Very low average (< 40): almost never hit trebles, mostly low scores
  const rand = Math.random();
  if(rand < 0.04) return 60; // T20 - almost never!
  if(rand < 0.05) return [57, 54][Math.floor(Math.random() * 2)]; // Other trebles - nearly impossible
  if(rand < 0.14) return [20, 19, 18][Math.floor(Math.random() * 3)]; // High singles - rare
  if(rand < 0.34) return [15, 16, 13, 14, 12, 11, 10, 9, 8][Math.floor(Math.random() * 9)]; // Mid singles
  return [5, 1, 7, 3, 6, 4, 2, 17, 11, 9, 12, 10, 8, 14][Math.floor(Math.random() * 14)]; // Lots of low scores - 66% of darts!
}

function undo(){
  if(Engine.state.undo.length){
    Engine.restore(Engine.state.undo.pop());
    render();
  }
}

$("throwInput").addEventListener("keydown",e=>{
  if(e.key==="Enter"){e.preventDefault();submitThrow();}
});

// Initialize the match when page loads
initMatch();
</script>

</body>
</html>
