<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Darts Scorer</title>
<link rel="stylesheet" href="style.css">
</head>

<body>

<div class="scoreboard">

  <div id="matchInfo" class="match-info"></div>

  <div class="top">
    <div class="player">
      <div id="p1Score" class="score">501</div>
      <div id="p1Name" class="name"></div>
    </div>

    <div class="center-stats">
      <div>LEGS<span id="p1Legs">0</span></div>
      <div>SETS<span id="p1Sets">0</span></div>
      <div>SETS<span id="p2Sets">0</span></div>
      <div>LEGS<span id="p2Legs">0</span></div>
    </div>

    <div class="player">
      <div id="p2Score" class="score">501</div>
      <div id="p2Name" class="name"></div>
    </div>
  </div>

  <div class="divider"></div>

  <div class="input-row">
    <button class="action" onclick="undo()">⟲</button>
    <input id="throwInput" class="throw" type="number" min="0" max="180" placeholder="Enter score">
    <button class="action" onclick="submitThrow()">➤</button>
  </div>

  <div class="hint">Press Enter to submit. Undo restores the last visit.</div>

  <div class="divider"></div>

  <div class="history-area">
    <div class="hist-col">
      <ul id="p1History" class="hist-list"></ul>
    </div>
    <div class="hist-col">
      <ul id="p2History" class="hist-list"></ul>
    </div>
  </div>

  <div class="divider"></div>

  <div class="bottom">
    <div class="stats">
      <h3>GAME AVERAGES</h3>
      <table>
        <tr><td>3 Dart</td><td id="p1Avg3" class="value">—</td></tr>
        <tr><td>1 Dart</td><td id="p1Avg1" class="value">—</td></tr>
      </table>
    </div>
    <div class="stats">
      <h3>GAME AVERAGES</h3>
      <table>
        <tr><td>3 Dart</td><td id="p2Avg3" class="value">—</td></tr>
        <tr><td>1 Dart</td><td id="p2Avg1" class="value">—</td></tr>
      </table>
    </div>
  </div>
</div>

<script>
let START = 501;
const $ = id => document.getElementById(id);

const Engine = {
  cfg:{},
  state:{
    p1Score:START,p2Score:START,
    p1Legs:0,p2Legs:0,
    p1Sets:0,p2Sets:0,
    turn:0,
    p1Hist:[],p2Hist:[],
    p1Pts:0,p2Pts:0,
    p1Turns:0,p2Turns:0,
    undo:[]
  },

  snapshot(){ return JSON.parse(JSON.stringify(this.state)); },
  restore(s){ this.state=s; },

  resetLeg(next){
    const s=this.state;
    s.p1Score=s.p2Score=START;
    s.turn=next;
    s.p1Hist=[{type:"start",score:START}];
    s.p2Hist=[{type:"start",score:START}];
    s.p1Pts=s.p2Pts=0;
    s.p1Turns=s.p2Turns=0;
  },

  apply(score){
    const s=this.state;
    
    // Limit undo stack to last 10 moves for performance
    s.undo.push(this.snapshot());
    if(s.undo.length > 10){
      s.undo.shift(); // Remove oldest
    }

    const isP1=s.turn===0;
    const cur=isP1?s.p1Score:s.p2Score;
    const hist=isP1?s.p1Hist:s.p2Hist;

    if(isP1)s.p1Turns++; else s.p2Turns++;

    const after=cur-score;
    if(after<0||after===1){
      hist.push({type:"bust"});
      s.turn^=1;
      return;
    }

    hist.push({type:"turn",scored:score,to:after});
    if(isP1){s.p1Score=after;s.p1Pts+=score;}
    else{s.p2Score=after;s.p2Pts+=score;}

    if(after===0){
      hist.push({type:"finish"});
      this.winLeg(isP1?0:1);
      return;
    }
    s.turn^=1;
  },

  winLeg(w){
    const s=this.state;
    if(w===0)s.p1Legs++; else s.p2Legs++;

    if(s.p1Legs===this.cfg.legs||s.p2Legs===this.cfg.legs){
      if(s.p1Legs===this.cfg.legs)s.p1Sets++;
      else s.p2Sets++;
      s.p1Legs=s.p2Legs=0;
    }
    this.resetLeg(w^1);
  }
};

function renderHist(id,h){
  const ul=$(id); 
  
  // Only render the last 15 items for performance
  const maxDisplay = 15;
  const startIdx = Math.max(0, h.length - maxDisplay);
  const itemsToShow = h.slice(startIdx);
  
  // Only update if changed
  const newHTML = itemsToShow.map(e => {
    if(e.type==="start"){
      return `<li class="hist-item start">${e.score}</li>`;
    }else if(e.type==="turn"){
      return `<li class="hist-item"><span class="scored">${e.scored}</span><span class="remain">${e.to}</span></li>`;
    }else if(e.type==="bust"){
      return `<li class="hist-item bust">BUST</li>`;
    }else if(e.type==="finish"){
      return `<li class="hist-item finish">FINISH</li>`;
    }
    return '';
  }).join('');
  
  if(ul.innerHTML !== newHTML){
    ul.innerHTML = newHTML;
    // Auto-scroll to bottom to show latest
    const container = ul.parentElement;
    if(container){
      container.scrollTop = container.scrollHeight;
    }
  }
}

function render(){
  const s=Engine.state;
  
  // Update scores only if changed
  const p1ScoreEl = $("p1Score");
  const p2ScoreEl = $("p2Score");
  if(p1ScoreEl.textContent !== s.p1Score.toString()) p1ScoreEl.textContent = s.p1Score;
  if(p2ScoreEl.textContent !== s.p2Score.toString()) p2ScoreEl.textContent = s.p2Score;
  
  // Update legs/sets
  $("p1Legs").textContent=s.p1Legs;
  $("p2Legs").textContent=s.p2Legs;
  $("p1Sets").textContent=s.p1Sets;
  $("p2Sets").textContent=s.p2Sets;

  renderHist("p1History",s.p1Hist);
  renderHist("p2History",s.p2Hist);

  // Update averages
  $("p1Avg3").textContent=s.p1Turns?(s.p1Pts/s.p1Turns).toFixed(2):"—";
  $("p2Avg3").textContent=s.p2Turns?(s.p2Pts/s.p2Turns).toFixed(2):"—";
  $("p1Avg1").textContent=s.p1Turns?(s.p1Pts/s.p1Turns/3).toFixed(2):"—";
  $("p2Avg1").textContent=s.p2Turns?(s.p2Pts/s.p2Turns/3).toFixed(2):"—";
}

function initMatch(){
  // Load config from localStorage
  const configStr = localStorage.getItem("dartsConfig");
  if(!configStr){
    alert("No match configuration found. Redirecting to setup...");
    window.location.href = "gamesetup.html";
    return;
  }
  
  Engine.cfg = JSON.parse(configStr);
  
  // Set the starting score based on game type
  START = Engine.cfg.gameType || 501;
  
  Engine.resetLeg(0);
  
  $("p1Name").textContent=Engine.cfg.p1;
  $("p2Name").textContent=Engine.cfg.p2;
  
  // Update match info text
  let matchText = `${START} GAME`;
  if(Engine.cfg.sets > 0){
    matchText += ` — FIRST OF ${Engine.cfg.sets} SETS`;
  }
  matchText += ` — FIRST OF ${Engine.cfg.legs} LEGS`;
  
  $("matchInfo").textContent = matchText;
  
  render();
  $("throwInput").focus();
  
  // If AI starts, play their turn
  if(Engine.cfg.isAI && Engine.state.turn === 1){
    $("throwInput").disabled = true;
    requestAnimationFrame(() => {
      setTimeout(() => {
        playAITurn();
        $("throwInput").disabled = false;
        $("throwInput").focus();
      }, 800);
    });
  }
}

function submitThrow(){
  const v=+$("throwInput").value;
  $("throwInput").value="";
  if(v<0||v>180)return;
  Engine.apply(v);
  render();
  
  // Check if it's AI's turn and game is still active
  if(Engine.cfg.isAI && Engine.state.turn === 1 && Engine.state.p2Score > 0){
    // Disable input during AI turn
    $("throwInput").disabled = true;
    
    // Use requestAnimationFrame for smoother performance
    requestAnimationFrame(() => {
      setTimeout(() => {
        playAITurn();
        $("throwInput").disabled = false;
        $("throwInput").focus();
      }, 600); // Reduced from 800ms for faster play
    });
  }
}

function playAITurn(){
  const avg = Engine.cfg.aiAverage;
  const checkoutPct = Engine.cfg.aiCheckout / 100;
  const remaining = Engine.state.p2Score;
  
  let score;
  
  // Determine if AI is on a finish
  if(remaining <= 170 && remaining !== 169 && remaining !== 168 && remaining !== 166 && 
     remaining !== 165 && remaining !== 163 && remaining !== 162 && remaining !== 159){
    
    // Checkout difficulty modifier
    let checkoutDifficulty = 1.0;
    if(remaining <= 40) checkoutDifficulty = 1.5;
    else if(remaining <= 100) checkoutDifficulty = 1.2;
    else checkoutDifficulty = 0.7;
    
    const adjustedCheckoutChance = checkoutPct * checkoutDifficulty;
    
    if(Math.random() < adjustedCheckoutChance){
      score = remaining; // Successfully finish
    } else {
      // Miss the checkout - play it safe and smart
      score = simulateCheckoutAttempt(avg, remaining);
    }
  } else {
    // Not on a finish - normal scoring
    score = simulateThreeDarts(avg, remaining, false);
  }
  
  Engine.apply(score);
  
  // Use requestAnimationFrame for smoother rendering
  requestAnimationFrame(() => render());
}

// Simulate a checkout attempt that misses
function simulateCheckoutAttempt(average, remaining){
  // Professionals play SAFE on checkouts - they won't bust from standard finishes
  // They aim for setup shots and only risk busting when going for the actual double
  
  const trebleRate = getTrebleRate(average);
  let score = 0;
  
  // Common checkout routes and what happens when you miss
  if(remaining <= 40){
    // Single dart at double - if miss, usually hit single or close
    const doubleRate = trebleRate * 0.7;
    if(Math.random() < doubleRate){
      return remaining; // Hit the double
    } else {
      // Missed double - hit single or nearby
      return Math.floor(remaining / 2) + Math.floor(Math.random() * 10);
    }
  } else if(remaining <= 60){
    // Usually S20 then double - if miss double, leave small number
    const dart1 = Math.random() < trebleRate ? 60 : 20;
    score += dart1;
    const left = remaining - score;
    
    if(left <= 40 && left > 0){
      const doubleRate = trebleRate * 0.7;
      if(Math.random() < doubleRate){
        return remaining; // Finished
      } else {
        // Missed double, hit single or close
        score += Math.floor(left / 2) + Math.floor(Math.random() * 8);
        return Math.min(score, remaining - 2); // Never bust, leave even
      }
    }
    return score;
  } else if(remaining <= 100){
    // Need 2 darts to set up - professionals WON'T BUST
    // Example: 80 = T20(60) + D10(20) or S20(20) + T20(60) + D0
    
    // Dart 1: Aim for T20 or S20
    const dart1 = Math.random() < trebleRate ? 60 : 20;
    score += dart1;
    let left = remaining - score;
    
    // Dart 2: Be smart - don't bust
    if(left <= 40){
      // Can finish with one dart
      const doubleRate = trebleRate * 0.7;
      if(Math.random() < doubleRate){
        return remaining; // Finished
      } else {
        // Miss double - add single or nearby
        score += Math.floor(left / 2) + Math.floor(Math.random() * 6);
      }
    } else if(left < remaining){
      // Setup for next turn - aim for T20 or S20, but DON'T BUST
      const safeMax = left - 2; // Never leave 1 or bust
      const dart2Options = Math.random() < trebleRate ? 
        [60, 57, 54] : [20, 19, 18, 5, 1];
      
      let dart2 = dart2Options[Math.floor(Math.random() * dart2Options.length)];
      
      // Safety check - don't bust
      if(score + dart2 > remaining){
        dart2 = Math.min(20, remaining - score - 2);
      }
      
      score += dart2;
      left = remaining - score;
      
      // Dart 3: Only if we can finish or setup
      if(left <= 40 && left > 0){
        const doubleRate = trebleRate * 0.7;
        if(Math.random() < doubleRate){
          return remaining; // Finished
        } else {
          score += Math.floor(left / 2) + Math.floor(Math.random() * 5);
        }
      }
    }
    
    // Ensure we didn't bust and didn't leave 1
    if(score >= remaining) score = remaining - (2 + Math.floor(Math.random() * 20));
    if(remaining - score === 1) score -= 1;
    
    return Math.max(0, score);
  } else {
    // 101-170: Need multiple big scores
    score = simulateThreeDarts(average, remaining, true);
    
    // Make sure didn't bust
    if(score >= remaining){
      score = remaining - (10 + Math.floor(Math.random() * 30));
    }
    return Math.max(0, score);
  }
}

function getTrebleRate(average){
  if(average >= 105) return 0.46;
  else if(average >= 100) return 0.43;
  else if(average >= 95) return 0.40;
  else if(average >= 85) return 0.36;
  else if(average >= 75) return 0.30;
  else if(average >= 60) return 0.22;
  else if(average >= 45) return 0.14;
  else return 0.07;
}

// Simulate throwing 3 darts based on skill level
function simulateThreeDarts(average, remaining, isCheckoutAttempt){
  // Calculate treble hit percentage based on ACTUAL PDC statistics
  const trebleHitRate = getTrebleRate(average);
  
  let totalScore = 0;
  
  // Throw 3 darts
  for(let i = 0; i < 3; i++){
    const dartScore = throwSingleDart(trebleHitRate, average, false, 0, i);
    totalScore += dartScore;
  }
  
  return totalScore;
}

// Simulate a single dart throw
function throwSingleDart(trebleHitRate, average, isCheckout, remainingInTurn, dartNumber){
  // Regular scoring dart - aim for T20
  const hitTreble = Math.random() < trebleHitRate;
  
  if(hitTreble){
    // Hit a treble - mostly T20, sometimes T19 or T18
    const trebleChoice = Math.random();
    if(trebleChoice < 0.75) return 60;      // T20 - most common
    else if(trebleChoice < 0.90) return 57; // T19
    else if(trebleChoice < 0.97) return 54; // T18
    else return 51;                          // T17
  } else {
    // Missed treble - where did we land?
    const missType = Math.random();
    
    if(missType < 0.40){
      // Hit single of target number (S20, S19, S18)
      const singleChoice = Math.random();
      if(singleChoice < 0.65) return 20;      // S20
      else if(singleChoice < 0.85) return 19; // S19
      else return 18;                         // S18
    } else if(missType < 0.70){
      // Hit adjacent single (S5, S1 near T20)
      const adjacentChoice = Math.random();
      if(adjacentChoice < 0.5) return 5;  // S5 (left of 20)
      else return 1;                       // S1 (right of 20)
    } else if(missType < 0.85){
      // Hit single 20 bed but outer ring
      return 20;
    } else {
      // Complete miss - random low score
      return Math.floor(Math.random() * 15) + 1;
    }
  }
}

function undo(){
  if(Engine.state.undo.length){
    Engine.restore(Engine.state.undo.pop());
    render();
  }
}

$("throwInput").addEventListener("keydown",e=>{
  if(e.key==="Enter"){e.preventDefault();submitThrow();}
});

// Initialize the match when page loads
initMatch();
</script>

</body>
</html>